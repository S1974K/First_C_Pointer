# 第一章

## この章でわかること
- ポインタとは何か
- ポインタとメモリの関係性について
- ポインタのはたらき

1.1 ポインタを学ぶ前の確認事項
1.2 アドレスとメモリ
1.3 C言語におけるポインタ


## 1.1 ポインタを学ぶ前の確認事項
この教材は、C言語のポインタおよびそれに関連の深い事項に焦点を強く当てて学ぶものである。そのため、プログラミングの初歩的な知識やC言語の基本的な文法については予め理解していることを前提に進んでいく。学習者は以下の知識について習得していない場合、初歩的な内容を別媒体で学んでおくことを強く推奨する。
- C言語のコードの基本的な書き方と標準出力方法
- 変数の型と宣言
- 配列の型と宣言
- Cの演算子の優先順位

## 1.2 アドレスとメモリ

C言語におけるポインタの概念を理解する前に、アドレスをは何かを理解する必要がある。ここでは、アドレスとは何であるかを正しく理解することを目的とする。
アドレスとは、コンピュータが読み書きに使用するデータを保管している「メモリ」に関する概念だ。コンピュータでデータを扱う際、それらを格納し保存する記憶領域である「メモリ」に、区画ごとの整理のための番地のような番号が振られている。この区画ごとの番号を「アドレス」と呼び、格納されている情報にアクセスするのに使われる。格納されている値に必要なバイト数に応じて、割り当てられるアドレスの範囲が変化する。
具体例として、仮に`0010から0090`まで、通し番号のように用意されたメモリが存在すると仮定する。

```
0010
0011
0012
0013
.
.
.
0087
0088
0089
0090
```

アドレスというのは、ある値がメモリのどの場所に保存されているかを指す値だ。この時、`int a`と`int b`という変数がそれぞれ定義され値を持っているとすると、`int a`の値が格納されているメモリのアドレスと`int b`の値が格納されているメモリのアドレスがそれぞれ存在するということになる。
この節では仮に、aがアドレス`0010-0013`の範囲に、bがアドレス`0014-0017`の範囲に収納されていることにする。下の図のように、値が収納されることになる。

```
0010 ┐
0011 │ a
0012 │
0013 ┘
0014 ┐
0015 │ b
0016 │
0017 ┘
.
.
.
0089
0090
```

基本的にプログラムでは、このメモリ部分に変数の情報などを格納し、メモリから必要な情報を読み出して使用する。
C言語ではこのようにして、さまざまなオブジェクト（変数やメモリのうち、値を表現するそれぞれの部分を指す用語）をアドレスを使って読み出す。この時、アドレスを使ってオブジェクトを読み出し、値を取得することを「アクセスする」と言う。例えば、アドレス`0014`に「アクセス」することで変数`b`と言う変数が持つ値を得ることができる。

## 1.3 C言語におけるポインタ

！**重要**！
- ポインタとは、オブジェクトの格納されているアドレスを指し示すものである。
- ポインタ型とは、他の型から派生するように作られる型であり、ポインタ型を持つデータはアドレスを指している。
- ポインタ型の変数を宣言する際は、`int *a_pointer`, `char *s_pointer`などのように、`(アドレスの先に格納されるデータの型) *(変数名)`の形で宣言する。

### 1.3-1　ポインタとは何か
先の節で解説したアドレスとメモリの概念は、「ポインタ」の概念を理解するのに必要な知識である。この章では、「ポインタ」の解説や宣言について説明する。

ポインタとは、何らかのオブジェクトの格納されているアドレスを指し示すものである。すでに存在する型Xに対し、あるX型のデータのアドレスを指し示すような型を、X型へのアクセスを持つ型という意味で「Xへのポインタ型」と呼ぶ。

例として、1.2節で登場した変数a, bを挙げて考える。
`int`型の変数である`a`を指し示すアドレス`0010`を格納する変数`a_pointer`を用意するとき、それは「`int`へのポインタ型」をとる。同様に、`int`型の変数である`b`を指し示すアドレス`0014`を格納する変数`b_pointer`も「`int`へのポインタ型」をとる。

### 1.3-2　ポインタの宣言
基本的な型を指すポインタ変数は、ポインタが指す型と宣言する変数名によって
```
	(ポインタが指す型) *(変数名)
```
と宣言する。具体的な宣言例は以下の通りである。
```
	int *a; //int型の値へのポインタa
	char *b; //char型の値へのポインタb
```
アドレスを持つ値の型は、それが指す値の型によって変化する。上記の例で宣言したポインタ変数は、それぞれ「`int`へのポインタ型」「`char`へのポインタ型」である。
変数の宣言は型名と変数名の組み合わせで行われるが、ポインタであることを表す`*`は型名の一部であることに注意が必要である。このため、コードで宣言した上記のポインタ変数を
使用する際は、変数名に`*`を添えない。

また、指し示す先がオブジェクトであればポインタ型は新しく作成できる。したがって、アクセスする値が`int`や`char`など基本的な型でなくとも、配列型や関数型のオブジェクトから新しくポインタ型を作ることができる。

配列に関する型の具体例は以下の通りである。
```
	int (*p_to_array)[10]; //int型の要素を持つ要素数10の配列へのポインタp_array
	int *array_of_p[10]; //intへのポインタを要素に持つ要素数10の配列
```

ポインタ型もまた型の一つであるため、ポインタ型のポインタを作成することも可能である。
```
	int **p_pointer; //「int型へのポインタ」を指すポインタ変数p_pointer
```

さらに、関数を指すポインタも指定することができる。関数へのポインタを利用することで、ポインタを通して間接的に関数を呼び出すことができるようになる。
```
	int (*p_func)(int, *char); //int型の戻り値を持ち、引数にint型とcharへのポインタ型を持つ関数へのポインタp_func
```


### 1.3-4　ポインタ型変数への代入に際しての注意
ポインタ型の変数において、想定されている型を持つもの以外のデータを指すアドレスは代入することができない。　`int`のポインタ型変数`a_pointer`に`char`型の変数cのアドレスを代入することはできず、`char`型へのポインタ型変数`c_pointer`に`int`型の変数`a`のアドレスを代入することもできない。

`double`型を想定している変数に`int`型の値を代入するなど、変数と型がちがう値を代入する必要がある際は、キャスト演算子を使用する。キャスト演算子は以下のように扱う。
```
	(変換先の型) 型変換する式;
```
例えば、`int`型の変数`a`を`char`型に変換したい場合、変換先の変数を`b`として、
```
	b = (char) a;
```
となる。これはポインタ変数でも同じことができる。`int`型へのポインタ型の変数`x`を`char`型へのポインタ型に変換したい場合は、変換先の変数を`y`として、
```
	y = (char*) x;
```
と表現できる。




